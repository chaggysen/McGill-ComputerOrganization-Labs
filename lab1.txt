Lab 1
In this lab, we will learn how to work with an ARM processor and the basics of ARM assembly by programming some common routines. The following lecture content will be required for conducting this lab: compare instructions, branch instructions, shift instructions, load and store instructions, subroutines and function calls.

Part 1
In this part, we will implement a well-known optimization technique, namely stochastic gradient descent (SGD), which is the backbone of a wide range of machine learning algorithms. We will use the SGD technique to solve a simple problem: finding the square root of an integer number.

Let x2=a, where a∈Z+, the task is to calculate x=round(a−−√). Let L=(x2−a)24 be a loss function. The square root of a can be found (approximated) by finding x∗ that minimizes the loss function L, where x∗=argmin∀xL.

To find (estimate) x∗ using the SGD technique, at the first time step, i=0, we start with a (random) value of x0. The algorithm updates the estimate of x∗ by performing the following computation at each iteration

xi+1=xi−γ∗L′(xi)=xi−γ∗(x2i−a)xi,

where γ (0<γ<1) is the learning rate, i is the time step. To simplify the update equation, we choose γ to be in the form of 2−k and k∈Z+. In practice, the value of γ∗(x2−a)x is often constrained to be within an interval (−t,t), t>0, to enable numerical stability.

In C, finding the square root of an integer number a using the SGD technique with 100 iterations (cnt=100) can be implemented as:
int sqrtIter(int a, int xi, int cnt, int k, int t)
{
   for (int i=0; i<cnt; i++)
   {
        int step = ((xi*xi-a)*xi)>>k;
        if (step > t)
           step = t;
        else if(step< -t)
           step = -t;
        xi = xi - step;
   }
   return xi;
}

int x = sqrtIter(168, 1, 100, 10, 2); // Output: 13

In addition, the iterative approach used in the sqrtIter function can be alternatively transformed to a recursive manner as follows.

int sqrtRecur(int a, int xi, int cnt, int k, int t)
{
    if (cnt == 0)
        return xi;
    else
    {
        int grad = ((xi * xi - a) * xi) >> k;
        if (grad > t)
            grad = t;
        else if (grad < -t)
            grad = -t;
        xi = xi - grad;
        return sqrtRecur(a, xi, cnt - 1, k, t);
    }
}

int x = sqrtRecur(168, 1, 100, 10, 2); // Output: 13
In this part, your tasks consit of writing assembly programs to find the square root of an integer number a using different approaches. Note that in all cases, xi is stored in r0, a is stored in r1, and cnt is stored in r2. The values of k, and t are treated as immediate values and are fixed to 10, and 2, respectively. In addition, it is recommended that you perform the second exercise of Part 1 only once you will have covered function calls in the lecture.

Part 1 Exercises

Write an assembly program that implements the sqrtIter function.

Write an assembly program that implements the sqrtRecur function using subroutines and function calls.

.global _start
_start:

MOV R0, #0 // R0 will be step
MOV R1, #168 // R1=168 (a)
MOV R2, #1 // R2=1 (xi)
MOV R3, #100 // R3=100 (cnt)
MOV R4, #10 // R4=10 (k)
MOV R5, #2 // R5=2 (t)

LOOP:
	MUL R6, R2, R2 //xi*xi
	SUBS R7, R6, R1 // (xi*xi)-a
	MUL R8, R7, R2 // (xi*xi-a)*xi
	ASR R8, R8, R4 // ((xi*xi-1)*xi)>>k
	MOV R0, R8 // load content of R8 in R0(step)
	CMP R0, #2 // if (step > t)
	BGT GT
	CMP R0, #-2 //(if step < -t)
	BLT LT
	B YO
	
GT:
MOV R0, #2 // step = t if R5-R0<=0
B YO

LT:
MOV R0, #-2
B YO

YO:
SUBS R2, R2, R0
SUBS R3, R3, #1
BGT LOOP

STOP:
B STOP




Part 1.2:

.global _start
_start:

MOV R0, #1 // xi = 1
MOV R1, #168 // a = 168
MOV R2, #100 // cnt = 100
MOV R3, #0 // grad


FUNCTION:
CMP R2, #0
BEQ END
MUL R4, R0, R0 //xi*xi
SUBS R5, R4, R1 // (xi*xi)-a
MUL R6, R5, R0 // (xi*xi-a)*xi
ASR R6, R6, #10 // ((xi*xi-1)*xi)>>10
MOV R3, R6// load content of R6 in R3(grad)
CMP R3, #2 // if (grad > t)
MOVGT R3, #2
CMP R3, #-2 //(if grad < -t)
MOVLT R3, #-2
SUBS R0, R0, R3 //xi = xi - grad
SUBS R2, R2, #1 // counter - 1
BL FUNCTION

END:
B END


Part 2
In this part, your task is to calculate the norm of a vector (array). Let x={x0,x1,…xn−1} be a vector of size n. The norm of x is given as ||x||=x20+x21+⋯+x2n−1n−−−−−−−−−−−√.

Note that you can reuse one of the assembly programs in Part 1 to calculate the square root in the above equation. In addition, we only consider the length of x to be a power of 2, thus the division can be implemented by a right-shift operation.

Below is a C program that calculates the norm of a given vector (array) of size 4.

// Initialization
int array[] = {5, 6, 7, 8};
size_t n = sizeof(array) / sizeof(array[0]);
int log2_n = 0;
int *ptr;
int tmp = 0;
int norm = 1;
int cnt = 100;
int k = 10;
int t = 2;

// Calculate log_2(n)
while ((1 << log2_n) < n)
    log2_n++;

// Calculate the norm of the given array
ptr = &array[0];
for (int i = 0; i < n; i++)
{
    tmp += (*ptr) * (*ptr);
    ptr++;
}
tmp = tmp >> log2_n;
norm = sqrtIter(tmp, norm, cnt, k, t); // Output: 7
Part 2 Exercises

Understand the C program that calculates the norm of a vector (array), add comments to the C program if necessary.

Write an assembly that calculates the norm of a vector (array). Note that the length of the array is also given as a parameter of the program. If you did not manage to implement the sqrtIter function in part 1, simply call a dummy function that returns its argument and you will not loose any point as long as you can demonstrate you can call a function correctly (you may want to wait before implementing the function call until this has been covered in the lectures).